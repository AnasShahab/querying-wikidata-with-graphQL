\documentclass[12 pt, a4paper]{report}
%\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
%\usepackage{tabularx}
%\usepackage{array}
\usepackage{amsmath,amssymb,amsfonts, amsthm}
\usepackage{rotating}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\usepackage{tablefootnote}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%\newcommand{\citeauthor}[1]{\citeauthor*{#1}}

\usepackage{setspace}
%\usepackage[top=1 in,bottom=1 in,left=3.2 cm,right=2.6 cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
%\renewcommand{\baselinestretch}{2}
%\renewcommand{\thesection}{\arabic{section}}
%\raggedbottom
%\usepackage{cite}
%\usepackage{biblatex}
\usepackage[sort&compress,numbers]{natbib}
\usepackage[hidelinks]{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{rotating}
\usepackage{hyperref}
\usepackage{lipsum}
\usepackage{xcolor}
%\usepackage{afterpage}
\usepackage{parskip} 
%removes indentation but gives some spacing ebtween parae the
\usepackage{todonotes}
\usepackage[toc,acronym]{glossaries}

\usepackage{booktabs}
\usepackage{rotating}
%\usepackage{minted}
\usepackage{listings}
%\usepackage{float}
%\usepackage{caption}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
%    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
%    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    escapechar=\%,
    framexleftmargin=0.25mm,
    frame=single,
%    float=H,
%    escapeinside=``,
    rulecolor=\color{black}
%    moredelim=[s][\color{purple}]{<}{>}
%    alsoletter={<},  moredelim=[s][\color{blue}\bfseries]{<}{>},
%    moredelim=[is][\color{blue}\bfseries\ttfamily]{<}{>}
%    moredelim=[is][\color{blue\bfseries]{[}{]},  
%    flexiblecolumns=true	
}

%\lstdefinestyle{mystyle2}{
%    backgroundcolor=\color{backcolour},   
%    commentstyle=\color{codegreen},
%    keywordstyle=\color{magenta},
%    numberstyle=\tiny\color{codegray},
%    stringstyle=\color{codepurple},
%    basicstyle=\ttfamily\large,
%    breakatwhitespace=false,         
%    breaklines=true,                 
%    captionpos=b,                    
%    keepspaces=true,                 
%    numbers=none,                    
%    numbersep=5pt,                  
%    showspaces=false,                
%    showstringspaces=false,
%    showtabs=false,                  
%    tabsize=2,
%    escapechar=\%,
%    framexleftmargin=0.25mm,
%    frame=single,
%    rulecolor=\color{black}
%    flexiblecolumns=true	
%}

\lstset{style=mystyle}


\lstdefinelanguage{SPARQL}{
  keywords={BASE, PREFIX, SELECT, WHERE, ChemicalCompound_GET, Cat_GET, OPTIONAL, query},
  keywordstyle=\color{red}\bfseries,
  ndkeywords={FILTER, LANG, LIMIT, OFFSET, first, offset, limit, SERVICE,@optional, lang, COUNT, VALUES},
  ndkeywordstyle=\color{blue}\bfseries,
  moredelim=[s][\color{blue}]{<}{>},
%  alsoletter={\$}, moredelim=[s][\color{red}]{[},
%  alsoletter={[},  moredelim=[s][\color{red}\bfseries]{[}{]},  
%  identifierstyle=\color{black},
  sensitive=true
%  morecomment=[l]{\#},
%  morestring=[b]',
%  morestring=[b]",
%  alsodigit={-},
%  basicstyle=\ttfamily,  
%  stringstyle=\color{red}\itshape,
%  commentstyle=\color{gray}\ttfamily
%  literate=
%    {->}{{\(\rightarrow\)}}2
%    {<=}{{\(\leq\)}}2
%    {>=}{{\(\geq\)}}2
%    {|}{{\(\mid\)}}1
}

\lstdefinelanguage{GraphQL}{
  keywords={query,mutation,subscription,fragment,on, type, data, @context, subject, predicate, object, graph, results, ChemicalElement_GET, extensions, errors},
  keywordstyle=\color{red}\bfseries,
  keywords=[3]{String, Int, Float, Boolean, limit, ChemicalElement, first, offset, if, Quad, bindings, lang},
  keywordstyle=[3]\color{blue}\bfseries,
  keywords=[2]{chemicalElement, name, id, label, chemicalFormula, boilingPoint, meltingPoint, density, discoverer, placeBirth, country, wd, wdt, instance,_id, Human, City, SovereignState, _type, @vocab, cat, chemicalCompound, color, rgb, JohannSebastianBach, hasFather, fatherOf, hasMother, cathedral, place, Paris, Cat, ChemicalCompound, Color, Airport, connectingLine, coordinateLocation, placeServed},
  keywordstyle=[2]\color{codegreen}\bfseries,
%  morekeywordstyle=\color{green}\bfseries,
  moredelim=[s][\color{blue}]{"http}{"},
%  moredelim=[s][\color{purple}]{<}{>},
%  alsoletter={\$}, moredelim=[s][\color{red}]{[},
%  alsoletter={[},  moredelim=[s][\color{red}\bfseries]{[}{]},  
%  identifierstyle=\color{black},
  sensitive=true
%  morecomment=[l]{\#},
%  morestring=[b]',
%  morestring=[b]",
%  alsodigit={-},
%  basicstyle=\ttfamily,  
%  stringstyle=\color{red}\itshape,
%  commentstyle=\color{gray}\ttfamily
%  literate=
%    {->}{{\(\rightarrow\)}}2
%    {<=}{{\(\leq\)}}2
%    {>=}{{\(\geq\)}}2
%    {|}{{\(\mid\)}}1
}

\lstdefinelanguage{GraphQLException}{
  keywords={query,mutation,subscription,fragment,on, data, @context, results, chemicalElement, bindings},
  keywordstyle=\color{red}\bfseries,
  keywords=[3]{String, Int, Float, Boolean, limit, ChemicalElement, first, offset, if, Quad}, keywordstyle=[3]\color{blue}\bfseries,
  keywords=[2]{name, chemicalFormula, boilingPoint, meltingPoint, density, input, variables, type, subject, predicate, object, graph, value},
  keywordstyle=[2]\color{codegreen}\bfseries,
%  morekeywordstyle=\color{green}\bfseries,
  moredelim=[s][\color{blue}]{"http}{"},
  sensitive=true
}

\lstdefinelanguage{GraphQLException2}{
  keywords={Quad, chemicalElement},
  keywordstyle=\color{red}\bfseries,
%  keywords=[3]{String, Int, Float, Boolean, limit, ChemicalElement, first, offset, if, bindings},
%  keywordstyle=[3]\color{blue}\bfseries,
  keywords=[2]{termType, value, subject, predicate, object, graph, type, name, chemicalFormula, boilingPoint},
  keywordstyle=[2]\color{codegreen}\bfseries,
%  morekeywordstyle=\color{green}\bfseries,
  moredelim=[s][\color{blue}]{"http}{"},
  sensitive=true
}

\lstdefinelanguage{GraphQLException3}{
%  keywords={Quad, chemicalElement},
%  keywordstyle=\color{red}\bfseries,
%  keywords=[3]{String, Int, Float, Boolean, limit, ChemicalElement, first, offset, if, bindings},
%  keywordstyle=[3]\color{blue}\bfseries,
  keywords=[2]{name, schema, server, services},
  keywordstyle=[2]\color{codegreen}\bfseries,
%  morekeywordstyle=\color{green}\bfseries,
  moredelim=[s][\color{blue}]{"http}{"},
  sensitive=true
}

%\lstset{language=GraphQL}
\setlength {\marginparwidth }{2cm} 
\newcommand{\lukas}[1]{\todo[color=green,inline]{#1}}
\newcommand{\anas}[1]{\todo[color=red,inline]{#1}}

\newcommand{\blankpage}{
\newpage
\thispagestyle{empty}
\addtocounter{page}{-1}
\mbox{}
\newpage
}

%\newcommand\blankpage{%
%    \null
%    \thispagestyle{empty}%
%    \addtocounter{page}{-1}%
%    \newpage}

%\def\keywords{\vspace{.5em}
%{\textit{Keywords}:\,\relax%
%}}
%\def\endkeywords{\par}

%\providecommand{\keywords}[1]
%{
%  \small	
%  \textbf{\textit{Keywords---}} #1
%}

\counterwithout{footnote}{chapter}



%\input{chapters/glossary.tex}


\onehalfspacing
\begin{document}

%\maketitle
\sloppy
\input{chapters/title.tex}
\blankpage
%\afterpage{\blankpage}

%\thispagestyle{empty}
\pagenumbering{roman}
\chapter*{Declaration of originality}
%\section*{Declaration of originality}
I hereby declare that I have written this Thesis on my own accord and any participation of others has been acknowledged. I have clearly marked all references to existing work. I have not submitted this work partly or as a whole anywhere else. \\

Dresden, \textcolor{red}{XX.XX.2023} \\
\rule{150 px}{0.5 px} \\
\textcolor{red}{(signature)}
\blankpage
%\afterpage{\blankpage}

%\thispagestyle{empty}
\chapter*{Acknowledgements}
%\section*{Acknowledgements}
I want to thank Prof. Dr. Markus Kr{\"otzsch} for supervising and reviewing this thesis, and for giving me the opportunity to do it under the Chair of Knowledge-Based Systems. I want to thank Dr. D{\"o}rthe Arndt for reviewing this thesis as part of the formal assessment. I also want to deeply thank Lukas Gerlach for supporting and guiding me during the preparation of this thesis.

Lastly, I want to thank my family and friends for supporting and motivating me throughout this journey.
\blankpage

%\begin{abstract}
%\lipsum[1]
%\\[0.5 cm]
%\centerline{\keywords{x, y, z}}
%
%\end{abstract}

\chapter*{Abstract}
%\section*{Abstract}

A Knowledge graph is a collection of data stored in the form of graphs. It represents knowledge that conveys information about the real world. Knowledge graphs can be modelled using different graphs, the most commonly one being directed-edge labelled graphs. In such a graph, the nodes represent entities and the edges represent the relationships that exists between the entities. Knowledge graphs have several uses in commercial and research domains. Many large companies such as Google and Amazon use knowledge graphs in their applications. In the field of research, some of the popular uses of knowledge graphs are in data mining and machine learning.

Wikidata is a free and publicly available knowledge graph created at Wikimedia Deutschland. It is widely popular within the research community and has a vast range of commercial applications. Large organizations such as Apple and Amazon use Wikidata to enrich their products and services. Wikidata is a valuable resource for researchers in many scientific domains such as biomedical research and helps in collection of data in machine learning algorithms.

Resource Description Framework (RDF) is a framework that represents information in the form of Linked Data. RDF is based on a graph based data model, where it represents information in the form of directed-edge labelled graphs. Data in RDF is represented syntactically using triples, where a triple is a statement that consists of three parts - \textit{subject, predicate and object}. The subject and object correspond to the source and destination nodes in the graphs respectively, and represent entities. The predicate corresponds to an edge in the graphs, and represent the relationships between the entities. Several formats such as N-Triples and Turtle exists for exchanging graphs over the web. Both RDF and RDF Schema (RDFS) provide vocabulary that defines resources and properties. RDF is the primary data model for building knowledge graphs. Wikidata is built on top of RDF but it has some key differences with the RDF data model. One such example is the existence of optional qualifiers in Wikidata statements. 

SPARQL is a protocol and query language for RDF. It is based on matching graph patterns and is used to query RDF graphs. As a result, we use SPARQL to query knowledge graphs. SPARQL is a powerful query language as it is expressive, and provides many features to retrieve and manipulate data. However, SPARQL queries are complex in nature and have a steep learning curve. There are few tools and libraries available to developers for working with SPARQL. This poses a barrier to using and integrating SPARQL in applications to query data from knowledge graphs.

GraphQL is a popular query language for working with APIs. It queries data from a source using a set of fields and parameters that are defined in a schema. It is a flexible query language as users can retrieve exactly the data they need without issues of under or over fetching. They can shape the order of the query results as per their application needs. GraphQL is designed to have a human-oriented syntax. This makes it easy for developers to learn and implement it in applications. Moreover, there are many supporting resources that help the integration of GraphQL into the development of such systems.

The purpose of our work is to show ways of querying the knowledge graph, Wikidata, using GraphQL queries. This helps avoid the complexity of dealing with SPARQL queries, and makes use of the flexibility and features offered by GraphQL.

In this work, we show some key differences between GraphQL and SPARQL. Both the query languages were developed with different goals in mind. Developers are more experienced working with GraphQL queries than with the triple patterns that are part of SPARQL queries. They are also more equipped with working with GraphQL since fewer resources exist that support the integration of SPARQL into applications. Moreover, the complexity of SPARQL queries pose a barrier to developers to use SPARQL in commercial applications. However, SPARQL is more expressive than GraphQL since we can specify triple patterns and traverse entire graphs. GraphQL can only represent trees and retrieves data by starting from a root or parent node and then traversing along its descendants. SPARQL also supports federated querying using which it is possible to query and integrate data from multiple sources. GraphQL works with schemas that need to be defined each time a different source is queried. This makes integration of data from multiple sources difficult.

We show there are some existing commercial and open-source solutions to query RDF data via GraphQL. Our main focus is to introduce two open-source solutions, GraphQL-LD and HyperGraphQL, that can be used to query Wikidata via GraphQL queries. Both these approaches use GraphQL queries to act as layer of abstraction that hides the complexity of SPARQL queries. We show extensively how these approaches operate and the respective features that they offer. 

In this work, we provide details on how we can use GraphQL-LD and HyperGraphQL to fetch data from WIkidata and demonstrate the results. Since they are open-source, we made appropriate changes to the source code to implement the approaches on Wikidata. The changes were also made to help analyse the steps in the implementation and facilitate querying.

Our results show that some key differences between GraphQL-LD and HyperGraphQL in terms of implementation and features. We demonstrate these in this work extensively and compare them via examples against standard GraphQL and SPARQL features.

Both GraphQL and HypergraphQL are prospective choices for querying knowledge graphs like Wikidata. Each of them have their own merits and limitations. Since they are both work in progress, they do not have all the standard GraphQL features. However, as they are open-sourced there is a great scope for improvement and they can prove to be effective in fetching data having complex relationships. Moreover, our work proves that GraphQL is a viable solution to querying with RDF graphs and can effectively help lower the barrier that developers face when working with knowledge graphs.



%\pagenumbering{roman}
\tableofcontents
\newpage
%\renewcommand*{\lstlistingname}{List of XYZ}
\listoffigures
\newpage
\listoftables
\newpage
\lstlistoflistings
\addcontentsline{toc}{chapter}{\lstlistlistingname}
\newpage
\pagebreak

%\doublespacing
\pagenumbering{arabic}

\input{chapters/1-introduction}

\pagebreak

\input{chapters/2-preliminaries}

\pagebreak

\input{chapters/3-approaches}

\pagebreak

\input{chapters/4-implementation}

\pagebreak

\input{chapters/5-comparison}

\pagebreak

\input{chapters/6-conclusion}
%\appendix
\singlespacing
\bibliographystyle{ieeetr}
\bibliography{main}


%\printglossaries
\end{document}
