\chapter{Approaches for Querying RDF Graphs with GraphQL}

In this chapter, we focus on ways of queries\lukas{querying} RDF Graphs using GraphQL. In section XYZ of the previous chapter, we highlighted the differences between GraphQL and SPARQL. This gives rise to the idea of using GraphQL to query RDF graphs, thereby overcoming the limitations of using SPARQL directly.
\lukas{What gives rise to that? I think I would put the idea why we want to use GraphQL on RDF Graphs differently. Namely, it just seems natural because GraphQL already augments a Graph (Tree) structure in its original use case to be used for APIs. Also, which limitations of SPARQL would be overcome with that?}

In recent years, there have been attempts at providing approaches to querying linked data represented by RDF via GraphQL. This gave rise to several commercial and open-source solutions. Most notable ones include:

\begin{itemize}
	\item Stardog
	\item TopBraid EDG
	\item Ontotext Platform
	\item GraphQL-LD
	\item HyperGraphQL

\end{itemize}

Stardog\footnote{https://www.stardog.com/} is a commercial solution that offers a graph database called "Enterprise Knowledge Graph platform"\cite{Angele2022}. The initial versions only allowed querying their stored data using SPARQL. The support for querying using GraphQL was later added with the release of version 5.1. This solution allows users to provide a GraphQL schema. However, this is optional. When provided it can be used for translating GraphQL terms to RDF. The schema also helps in introspection purposes and for validating queries with the given typing information \cite{Gleim2020}. Introspection refers to querying GraphQL schema to find out the queries it supports. Moreover, schema also helps to limit the parts in the graph available to users, i.e., the user is only allowed to query some sections of the data available in the graph. If no schema is provided, then the conversion from GraphQL terms to RDF is done using the default namespace in that graph and can be overridden using the @prefix declarative inside the GraphQL queries \cite{Taelman2019}. However, this optional\lukas{optionally} requires the user to have a good knowledge about the way data is structured in the graph database. Introspection, data validation and access control is not possible when there is no schema \cite{Gleim2020}. In Stardog the top level node, also known as parent node, is considered to refer to a type. Any subsequent child nodes refer to the predicate links from the parent node \cite{Taelman2019}. This is an important distinction not necessarily shared by the other approaches.
\lukas{Thanks for looking into stardog! This is very interesting :)}

TopBraid Enterprise Data Governance (TopBraid DG) is also a commercial solution created by TopQuadrant\footnote{https://www.topquadrant.com/} to query RDF graphs using GraphQL. It uses GraphQL schemas that are automatically generated based on data shape definitions defined\lukas{definitions defined; maybe reword this sentence a bit} using SHACL\footnote{https://www.w3.org/TR/2017/REC-shacl-20170720/}, thereby exposing a GraphQL interface to RDF sources \cite{Taelman2019}. With the generation of schema, introspection also becomes possible. One important feature of TopBraid EDG is the functionality of query mutation. This allows the users to modify existing data in the graph.

Ontotext Platform\footnote{https://www.ontotext.com/products/ontotext-platform/} is a commercial solution offered by Ontotext. Users are provided with a GraphQL interface that they can to query the underlying graph database called "GraphDB" \cite{Angele2022}. 

The above mentioned proprietary solutions are not open source and only allow querying their corresponding graph databases. This implies they cannot be used to query arbitrary knowledge graphs such as Wikidata, which is the focus of this report.

GraphQL-LD and HyperGraphQL are two open source solutions that can be used to query knowledge graphs that provide a SPARQL endpoint. We talk in details about them in the following sections.\lukas{``we present'' rather than ``we talk''}

\section{GraphQL-LD}

GraphQL-LD is an academic approach\lukas{what is an academic approach?} introduced by Taelman et al.\lukas{you can use the citeauthor command} to query knowledge graphs via GraphQL \cite{Taelman2018}. The main working process behind this is to extend the GraphQL queries with JSON-LD context \cite{Sporny2014}.\lukas{maybe JSON-LD needs a little more introduction; could even be added to preliminaries} This helps to provide a link between the items in the nodes of the queries and the actual resources that exist in the respective knowledge graph. Listing XYZ and Listing XYZ shows an example where a query coupled with JSON-LD context can be used to fetch RDF data from a RDF data source - http://example.org\footnote{This domain is for use in illustrative examples in documents}. The JSON-LD context helps to identify the resources - chemicalElement, name, chemicalFormula and boilingPoint â€“ by providing an unique IRI specific to those resources in the RDF data source.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing6, caption={GraphQL query}]
{
	chemicalElement {
		name
		chemicalFormula
		boilingPoint
	}
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing7, caption={JSON-LD context}]
{
	"chemicalElement": "http://example.org/chemicalElement",
	"name": "http://example.org/name",
	"chemicalFormula": "http://example.org/chemicalFormula",
	"boilingPoint": "http://example.org/boilingPoint"
}
\end{lstlisting}
\end{minipage}

The approach taken by GraphQL-LD consists primarily of two standalone modules:
\begin{itemize}
	\item GraphQL to SPARQL algebra
	\item SPARQL results to tree
\end{itemize}


\subsection{GraphQL to SPARQL algebra}

The GraphQL to SPARQL module is used for parsing a GraphQL query into SPARQL algebra \lukas{I think sparql algebra should also be introduced (maybe I missed it)}(footnote: https://www.w3.org/TR/sparql11-query/\#sparqlQuery) with the help of a JSON-LD context. The algorithm for this conversion is based on translating the tree-like structure of GraphQL to links of triple patterns or statements  in SPARQL \cite{Taelman2018}. Listing XYZ shows the SPARQL algebra obtained by parsing the GraphQL query in Listing XYZ.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing8, caption={Generated SPARQL Algebra}]
{
  type: 'project',
  input: { type: 'bgp', patterns: [ [Quad], [Quad], [Quad], [Quad] ] },
  variables: [
    Variable { termType: 'Variable', value: 'chemicalElement_name' },
    Variable {
      termType: 'Variable',
      value: 'chemicalElement_chemicalFormula'
    },
    Variable {
      termType: 'Variable',
      value: 'chemicalElement_boilingPoint'
    }
  ]
}

\end{lstlisting}
\end{minipage}

It is also possible to view the generated SPARQL queries. This can be done from either the command line using the tool "graphql-to-sparql" or by invoking the programmatic API and calling the toSparql (or toSparqlJs) function on the SPARQL algebra. The generated SPARQL query for our example is shown in Listing XYZ.
\lukas{this might be unnecessarily technical for a reader that did not see the code. you can just say that there is a CLI tool for the translation}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing9, caption={Genertaed SPARQL query}]
SELECT ?chemicalElement_name ?chemicalElement_chemicalFormula ?chemicalElement_boilingPoint WHERE {
  ?df_3_0 <http://example.org/chemicalElement> ?chemicalElement.
  ?chemicalElement <http://example.org/name> ?chemicalElement_name;
    <http://example.org/chemicalFormula> ?chemicalElement_chemicalFormula;
    <http://example.org/boilingPoint> ?chemicalElement_boilingPoint.
}
\end{lstlisting}
\end{minipage}

GraphQL offers a lot of features like fragments, pagination and aliases. The official documentation of GraphQL has a comprehensive list of these features \cite{GraphQL}. All these features can be used in GraphQL-LD to increase the expressivity of the queries.\lukas{careful with such claims; they may be only syntactic sugar and not increase expressivity in a formal sense; furthermore I think a general issue is that pagination is more of a convention and a de-facto standard but not really part of graphql as such (thats the issue with not having an official semantics for GraphQL), fragments and aliases should be syntactic features so here I think this is fine and really part of graphql} Additionally, GraphQL has some custom directives\footnote{https://graphql.org/learn/queries/\#directives} that can be used to further enrich the queries. For instance, it allows the users to specify the fields that are optional using the "@optional" custom directive. This in turn converts to the OPTIONAL operator in SPARQL.

\subsection{SPARQL results to tree}

\section{HyperGraphQL}

