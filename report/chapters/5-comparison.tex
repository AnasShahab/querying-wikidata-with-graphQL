\chapter{Comparison of the approaches}

We compare the two approaches by highlighting the important similarities and differences they have among each other such as schema usage and the use of an intermediary server. The comparison also takes into account some important features that are typically associated with GraphQL queries.\footnote{https://graphql.org/learn/queries/ .}

SPARQL query language offers many features. We also provide a comparison of the SPARQL queries generated by the two approaches against the standard features typically offered by SPARQL. This gives us an idea of the limitations that each of these approaches have. To highlight the comparisons, some example SPARQL queries are also provided that query Wikidata to fetch data, and an attempt is made to use these two approaches to generate the same query.


\section{Schema}
HyperGraphQL uses a schema to allow the data that can be queried. This is similar to the original GraphQL specificiations. The schema then maps every type and relationship to an unique IRI which points to a resource in the RDF source. The advantage of using a schema is that we can limit the data that the user is allowed to query. 

However, this also means that some restriction in inevitable since we have to mention the type of every object node that is a resource. For example, in Wikidata the cat labelled Orangey (Q677525) is linked to several items through the property present in work (P1441). Each of these items are an instance of either a film or a television series but not both. When linking the property present in work to an item in the schema, we have to either define that item to be a film or television series, hence the limitation. Also, there are cases where we want all the nodes that have a particular relationship between them, and do not specify explicitly the type that each of the node belongs to. This is not possible in HyperGraphQL since we have to define for every resource a type. Moreover, every type and field in the schema can only be associated with one service. We mentioned in Chapter 3 Section XYZ the different services that are provided by HyperGrapHQL. 

On the other hand, GraphQL-LD operates schema-less. It translates a GraphQL query into a SPARQL query aided by a JSON-LD context. This context is responsible for mapping the GraphQL definitions to unique IRIs. The benefit of using no schema is that GraphQL is more flexible in the sense that RDF sources can be queried in the same fashion as one would use SPARQL queries against the endpoint. This removes the restrictions on the data that can be queried, and allows to simple query and relationships between nodes without mentioning the type of the nodes.

Since HyperGraphQL uses a schema, another advantage is that it distinguishes what should be queried as a type and what should be treated as a property \cite{Werbrouck2019a}. On the other hand, since GraphQL is predicate based, there is no direct way to distinguish this. We have to use workarounds to query for specific class.



\section{Intermediary server}
We create and run a HyperGraphQL instance by setting up an intermediary server using a configuration file and an annotated schema. A GraphQL endpoint is exposed that points to the service or Linked Data source configured in the parameters of the configuration file. However, when one needs to change the service, it required to stop the running intermediary server and create a new configuration file. Additionally, the annotated schema also required to be changed to comply with the new service. 

On the other hand, GraphQL-LD does not require the setup of a server. It can be executed simply via the command line by providing a GraphQL query, JSON-LD context and SPARQL endpoint. This implementation is relatively easier and provides more flexibility when one needs to query a different Linked Data source. 



\section{Updating data}
Updating existing data is an important feature when working with knowledge graphs. GraphQL implements this using the mutation operation type. Mutations allow the creation, update and deletion of data. SPARQL implements creation and deletion using the operations INSERT and DELETE respectively, and update using a combination of the two operations. However, neither GraphQL-LD nor HyperGraphQL currently support mutations. 

\section{Reverse Querying}
GraphQL-LD supports reverse querying as mentioned in section XYZ. This is useful in cases where we want to reverse the relationship between a parent and a child node. HyperGraphQL does not have the feature of reverse querying.

Table 2 provides a comparison of the two approaches with standard GraphQL features. 

\begin{table}[h]
	\begin{center}
		\caption{Comparison}
		\label{tab: table 2}
		\begin{tabular}{ccc}
		

			\toprule
			
			& \textbf{GraphQL-LD} & \textbf{HyperGraphQL}  \\ 
		
			\midrule
			
			Arguments & \cmark & \cmark \tablefootnote{only defined ones}	 \\
			
			Aliases & \cmark & \cmark  \\ 
			
			Fragments, Inline Fragments & \cmark & \cmark \tablefootnote{\cite{Werbrouck2019a} mentions possible but we could not implement it}  \\ 
			
			Operation name & \cmark & \cmark  \\ 
			
			Variables & \cmark & \cmark  \\ 
			
			Directives & \cmark & \cmark \\ 
			
			Mutations & \xmark & \xmark \\ 
			
			Pagination & \cmark & \cmark \\ 
			
			Introspection & \xmark & \cmark \\ 
			
			Pagination & \cmark & \cmark \\ 
			
			Nullability & \cmark & \cmark \tablefootnote{by default} \\ 
			
			Interfaces & \xmark & \xmark \\ 
			
			Union types & \xmark & \xmark \\ 	
			
			
			\bottomrule

		\end{tabular}
	\end{center}
\end{table}


\section{Generated SPARQL Queries}
HyperGraphQL translates fields into OPTIONAL SPARQL triple patterns. This cannot be changed in the annotated schema by making the fields non-null. This is a limitation since it is generally possible to define fields to be non-null in GraphQL schemas, hence we can expect the server to always return data that has this field. However, in HyperGraphQL we get more results than expected when writing GraphQL queries due to this limitation. 

GraphQL-LD does not have this limitation. Fields are non-null by default and can be defined nullable using the "optional" directive. This is one of the custom directives provided by GraphQL-LD.


\subsection{Querying Knowledge Graphs (Wikidata)}
In Wikidata we can use the specialized service with the URI <http://wikiba.se/ontology\#label> to fetch labels in specific languages. We cannot use this service in any of the approaches, and rdf:label\footnote{http://www.w3.org/2000/01/rdf-schema\#label} is used instead. GraphQL-LD cannot filter to fetch labels in some particular languages. It retrieves labels in all the available languages for the Wikidata resource. On the other hand, HyperGraphQL can fetch labels but do filtering to fetch labels in any one language. 

We compare the SPARQL queries generated by each of the two approaches, GraphQL-LD and HyperGraphQL, against some SPARQL queries taken from the official Wikidata documentation.\footnote{https://www.wikidata.org/wiki/Wikidata:SPARQL\_query\_service/queries/examples.} The queries used for evaluation are selected based on the different functionalities of SPARQL that can be used for fetching data from Wikidata, and customized as needed to highlight the comparison better. For each SPARQL query taken from the Wikidata website, an attempt is made to use two approaches to generate an equivalent SPARQL query. When it is possible to generate such a query, it is shown along with the corresponding GraphQL query is also shown.

Listings XYZ and XYZ show the JSON-LD context used by GraphQL-LD and the annotated schema used by HyperGraphQL respectively. For writing the GraphQL query for graphQL-LD we use the ID-based solution (Solution 2) shown in Chapter XYZ Section XYZ for the workaround.


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing34, caption={JSON-LD Context}]
{
  "@context": {
    "wd": "http://www.wikidata.org/entity/",
    "wdt" :"http://www.wikidata.org/prop/direct/",
    "instance": "wdt:P31",
    "cat": "wd:Q146",
    "label": "http://www.w3.org/2000/01/rdf-schema#label",
    "chemicalCompound": "wd:Q11173",
    "color": "wdt:P462",
    "rgb": "wdt:P465"
  }
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing34, caption={HyperGraphQL Annotated Scehma}]
type __Context {
    Cat:   _@href(iri: "http://www.wikidata.org/entity/Q146")
    label:  _@href(iri: "http://www.w3.org/2000/01/rdf-schema#label")
    ChemicalCompound: _@href(iri: "http://www.wikidata.org/entity/Q11173")
    color: _@href(iri: "http://www.wikidata.org/prop/direct/P462")
    Color: _@href(iri: "http://www.wikidata.org/entity/Q1075")
    rgb: _@href(iri: "http://www.wikidata.org/prop/direct/P465")
    Airport:_@href(iri: "http://www.wikidata.org/entity/Q1248784")
    connectingLine: _@href(iri: "http://www.wikidata.org/prop/direct/P81")
    placeServed: _@href(iri: "http://www.wikidata.org/prop/direct/P931")
    City: _@href(iri: "http://www.wikidata.org/entity/Q515")
    coordinateLocation: _@href(iri: "http://www.wikidata.org/prop/direct/P625")
}

type Cat @service(id:"wikidata-sparql") {
    label: [String] @service(id:"wikidata-sparql")
}

type ChemicalCompound @service(id:"wikidata-sparql") {
    label: [String] @service(id:"wikidata-sparql")
    color: [Color] @service(id:"wikidata-sparql")
}

type Color @service(id:"wikidata-sparql") {
    label: [String] @service(id:"wikidata-sparql")
    rgb: [String] @service(id:"wikidata-sparql")
}

type Airport @service(id:"wikidata-sparql") {
    label: [String] @service(id:"wikidata-sparql")
    connectingLine: [Airport] @service(id:"wikidata-sparql")
    placeServed: [City] @service(id:"wikidata-sparql")
}

type City @service(id:"wikidata-sparql") {
    label: [String] @service(id:"wikidata-sparql")
    coordinateLocation: [String] @service(id:"wikidata-sparql")
}
\end{lstlisting}
\end{minipage}

\subsubsection{LIMIT and OFFSET \\Simple query to fetch items whose value of instance of is a house cat.}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing34, caption={Query 1}]
SELECT ?item ?itemLabel
WHERE
{
    ?item wdt:P31 wd:Q146;.
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
} OFFSET 2 LIMIT 10
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing35, caption={Query 1 - GraphQL-LD}]
{
    id(instance:cat first: 10 offset: 2) {
        id
        label
    }
}


SELECT ?id ?id_id ?id_label WHERE {
  SELECT ?id_id ?id_label WHERE {
    ?id_id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q146>;
      <http://www.w3.org/2000/01/rdf-schema#label> ?id_label.
  }
  OFFSET 2
  LIMIT 10
}
\end{lstlisting}
\end{minipage}




\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing36, caption={Query 1 - HypergraphQL}]
{
  Cat_GET(limit: 10, offset: 2) {
    _id
    label(lang: "en")
  }
}


SELECT * WHERE {
  {
    SELECT ?x_1 WHERE {
      ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q146> .
    } LIMIT 10 OFFSET 2
  }
  OPTIONAL {
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1 .
    FILTER (lang(?x_1_1) = "en") .
  }
}
\end{lstlisting}
\end{minipage}


\subsubsection{OPTIONAL \\Query to fetch the colors of chemical compounds and optional the RDG of the colors.}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing37, caption={Query 2}]
SELECT ?compound ?color ?rgb  WHERE
{
  ?compound wdt:P31 wd:Q11173;
            wdt:P462 ?color.
  OPTIONAL { ?color wdt:P465 ?rgb. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing38, caption={Query 2 - GraphQL-LD}]
{
    id(instance:compound) {
        id
        label
        color{
            id
            label
            rgb @optional
        }
    }
}


SELECT ?id ?id_id ?id_label ?id_color_id ?id_color_label ?id_color_rgb WHERE {
  ?id_id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q11173>;
    <http://www.w3.org/2000/01/rdf-schema#label> ?id_label;
    <http://www.wikidata.org/prop/direct/P462> ?id_color_id.
  ?id_color_id <http://www.w3.org/2000/01/rdf-schema#label> ?id_color_label.
  OPTIONAL { ?id_color_id <http://www.wikidata.org/prop/direct/P465> ?id_color_rgb. }      
}
\end{lstlisting}
\end{minipage}



\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing39, caption={Query 2 - HyperGraphQL}]
{
  ChemicalCompound_GET {
    _id
    label(lang: "en")
    color {
      _id
      label(lang: "en")
      rgb
    }
  }
}


SELECT * WHERE { 
  { 
    SELECT ?x_1 WHERE { 
      ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q11173> . 
    }  
  }  
  OPTIONAL { 
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1 .
    FILTER (lang(?x_1_1) = "en") .  
  }  
  OPTIONAL { 
    ?x_1 <http://www.wikidata.org/prop/direct/P462> ?x_1_2 .
    ?x_1_2 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1075> . 
    OPTIONAL { 
      ?x_1_2 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_2_1 .
      FILTER (lang(?x_1_2_1) = "en") .  
    }  
    OPTIONAL { 
      ?x_1_2 <http://www.wikidata.org/prop/direct/P465> ?x_1_2_2 . 
    }  
  }  
}
\end{lstlisting}
\end{minipage}



\subsubsection{COUNT \\Counts the total number of humans in Wikidata.}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing40, caption={Query 3}]
SELECT (COUNT(*) AS ?count)
WHERE {
  ?item wdt:P31 wd:Q5 .
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing41, caption={Query 3 - GraphQL-LD}]
{
    id(instance: human){
        totalCount
    }
}


SELECT ?id ?id_totalCount WHERE { 
  SELECT (COUNT(?id) AS ?id_totalCount) WHERE { 
    ?id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q5>. 
  } 
}
\end{lstlisting}
\end{minipage}


HyperGraphQL does not support the use of functions. As a result, Query 3 cannot be implemented in HyperGraphQL.



\subsubsection{VALUE \\Fetches the destinations that can be reached from Antwerp International airport.}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing43, caption={Query 4}]
SELECT ?connectsairport ?connectsairportLabel ?place_served ?place_servedLabel ?coor
WHERE
{
  VALUES ?airport { wd:Q17480 }  
?airport wdt:P81 ?connectsairport ;
           wdt:P625 ?base_airport_coor .
  ?connectsairport wdt:P931 ?place_served ;
                   wdt:P625 ?coor .

  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}

Query 4 cannot be written in GraphQL-LD as it does not support the use of VALUES clause.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=listing:listing44, caption={Query 4 - HyperGraphQL}]
{
  Airport_GET_BY_ID(uris: ["http://www.wikidata.org/entity/Q17480"]) {
    _id
    label(lang: "en")
    connectingLine {
      _id
      label(lang: "en")
      placeServed {
        _id
        label(lang: "en")
        coordinateLocation
      }
    }
  }
} 


SELECT * WHERE {
  VALUES ?x_1 { <http://www.wikidata.org/entity/Q17480> }
  ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1248784> .
  OPTIONAL {
    ?x_1 <http://www.wikidata.org/prop/direct/P81> ?x_1_1 .
    ?x_1_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1248784> .
    OPTIONAL {
      ?x_1_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1_1 .
      FILTER (lang(?x_1_1_1) = "en") .
    }
    OPTIONAL {
      ?x_1_1 <http://www.wikidata.org/prop/direct/P931> ?x_1_1_2 .
      ?x_1_1_2 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q515> .
      OPTIONAL {
        ?x_1_1_2 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1_2_1 .
        FILTER (lang(?x_1_1_2_1) = "en") .
      }
      OPTIONAL {
        ?x_1_1_2 <http://www.wikidata.org/prop/direct/P625> ?x_1_1_2_2 .
      }
    }
  }
  OPTIONAL {
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_2 .
    FILTER (lang(?x_1_2) = "en") .
  }
}

\end{lstlisting}
\end{minipage}


Table 3 provides a comparison of the two approaches with standard SPARQL features.

\begin{table}[h]
	\begin{center}
		\caption{Comparison}
		\label{tab: table 2}
		\begin{tabular}{ccc}
		

			\toprule
			
			& \textbf{GraphQL-LD} & \textbf{HyperGraphQL}  \\ 
		
			\midrule
			
			LIMIT & \cmark & \cmark	 \\
			
			OFFSET & \cmark & \cmark  \\ 
			
			ORDER BY & \xmark & \xmark  \\ 
			
			GROUP BY & \xmark & \xmark  \\ 
			
			FILTER & \xmark & \cmark \tablefootnote{only for lang labels}  \\ 
			
			ASK/CONSTRUCT/DESCRIBE & \xmark & \xmark \\ 
			
			DISTINCT & \xmark & \xmark \\ 
			
			UNION & \xmark & \xmark \\ 
			
			MINUS & \xmark & \xmark \\ 
			
			OPTIONAL & \cmark & \cmark \\ 
			
			VALUES & \xmark & \cmark \tablefootnote{only for subject queries} \\ 
			
			BIND & \xmark & \xmark \\ 	
			
			COUNT & \cmark & \xmark \\ 			
			
			Other Aggregates & \xmark & \xmark \\ 	
			
			HAVING & \xmark & \xmark \\ 	
			
			
			\bottomrule

		\end{tabular}
	\end{center}
\end{table}

Both GraphQL-LD and HyperGraphQL are potential solutions of querying RDF graphs using GraphQL. They have their own benefits and limitations. Since they query tree structures, they are less expressive than SPARQL \cite{Werbrouck2019}. On the other hand, they facilitate querying basic RDF data using GraphQL queries. They support many standard features that are typical in GraphQL. However, both of the approaches are work in progress and have their own limitations. Hence, not all the expressivity of GraphQL can currently be implemented \cite{Werbrouck2019}.

When comparing between each other, GraphQL-LD is more suitable when we want to query different datasets by changing our endpoints as it operates without a schema and does not require the setup of a server. It also takes less time to implement it as opposed to HyperGraphQL.

On the other hand, HyperGraphQL is preferable when we want to query fixed datasets such as as Wikidata. An uniform setup with predefined set of types and fields in the annotated schema makes it stable and friendlier to use \cite{Werbrouck2019a}. 
