\chapter{Comparison of GraphQL-LD and HyperGraphQL}
\label{ch:5}
In this chapter, we compare GraphQL-LD and HyperGraphQL by highlighting the important similarities and differences they have among each other. At the end of the chapter, we provide tables that summarize the comparison against the features of GraphQL and SPARQL respectively.

The comparison is based on the following criteria:
\begin{itemize}
\item Implementation specific details such as usage of schema.
\item Standard GraphQL features such as passing arguments into fields.
\item Important SPARQL features such aggregates and values.
\end{itemize}

We provide examples (when applicable) to demonstrate the comparison, where each example consists of the following:

\begin{itemize}
\item A SPARQL query taken from the official Wikidata documentation\footnote{https://www.wikidata.org/wiki/Wikidata:SPARQL\_query\_service/queries/examples}.
\item A GraphQL query in GraphQL-LD accompanied with the corresponding generated SPARQL query.
\item A GraphQL query in HyperGraphQL accompanied with the corresponding generated SPARQL query.
\end{itemize}

For our examples we use the the JSON-LD context (used by GraphQL-LD) and the annotated schema (used by HyperGraphQL) shown in Listings~\ref{lst:35} and \ref{lst:36} respectively. For writing GraphQL queries in GraphQL-LD we use the \textit{ID based} solution.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:35, caption={JSON-LD Context in GrahQL-LD}, language=GraphQL]
{
  "@context": {
  	"@vocab":"http://www.wikidata.org/entity/", 
  	"wd": "http://www.wikidata.org/entity/",
  	"wdt" :"http://www.wikidata.org/prop/direct/",
  	"instance": "wdt:P31",
  	"cat": "wd:Q146",
  	"label": "http://www.w3.org/2000/01/rdf-schema#label",
  	"chemicalCompound": "wd:Q11173",
  	"color": "wdt:P462",
  	"rgb": "wdt:P465",
  	"JohannSebastianBach": "wd:Q1339",
  	"hasFather": "wdt:P22",
  	"fatherOf": { "@reverse":"wdt:P22" },
  	"hasMother": "wdt:P25",
  	"cathedral": "wd:Q2977",
  	"place": "wdt:P131",
  	"Paris": "wd:Q90"
  }
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:36, caption={Annotated Scehma in HyperGraphQL}, language=GraphQL]
type __Context {
  Cat:   _@href(iri: "http://www.wikidata.org/entity/Q146")
  label:  _@href(iri: "http://www.w3.org/2000/01/rdf-schema#label")
  ChemicalCompound: _@href(iri: "http://www.wikidata.org/entity/Q11173")
  color: _@href(iri: "http://www.wikidata.org/prop/direct/P462")
  Color: _@href(iri: "http://www.wikidata.org/entity/Q1075")
  rgb: _@href(iri: "http://www.wikidata.org/prop/direct/P465")
  Airport:_@href(iri: "http://www.wikidata.org/entity/Q1248784")
  connectingLine: _@href(iri: "http://www.wikidata.org/prop/direct/P81")
  placeServed: _@href(iri: "http://www.wikidata.org/prop/direct/P931")
  City: _@href(iri: "http://www.wikidata.org/entity/Q515")
  coordinateLocation: _@href(iri: "http://www.wikidata.org/prop/direct/P625")
}

type Cat @service(id:"wikidata-sparql") {
  label: [String] @service(id:"wikidata-sparql")
}

type ChemicalCompound @service(id:"wikidata-sparql") {
  label: [String] @service(id:"wikidata-sparql")
  color: [Color] @service(id:"wikidata-sparql")
}

type Color @service(id:"wikidata-sparql") {
  label: [String] @service(id:"wikidata-sparql")
  rgb: [String] @service(id:"wikidata-sparql")
}

type Airport @service(id:"wikidata-sparql") {
  label: [String] @service(id:"wikidata-sparql")
  connectingLine: [Airport] @service(id:"wikidata-sparql")
  placeServed: [City] @service(id:"wikidata-sparql")
}

type City @service(id:"wikidata-sparql") {
  label: [String] @service(id:"wikidata-sparql")
  coordinateLocation: [String] @service(id:"wikidata-sparql")
}
\end{lstlisting}
\end{minipage}


\section{Schema}
HyperGraphQL uses schemas for querying. This is similar to the original GraphQL specificiations. The schema maps every type and relationship to an unique IRI that points to a resource in the RDF source. The advantage of using a schema is that we can limit data that the user is allowed to query. 

However, this also means that some restriction in inevitable since we have to mention the type of every object node that is a resource. For example, in Wikidata the cat labelled \textit{Orangey} \texttt{(Q677525}) is linked to several items through the property \textit{present in work} \texttt{(P1441)}. Each of these items are an instance of either a \textit{film} or a \textit{television series} but not both. When linking the property present in work to an item in the schema, we have to either define that item to be a \textit{film} or \textit{television series}, hence the limitation. Also, there are cases where we want all the nodes that have a particular relationship between them, and do not specify explicitly the type that each of the node belongs to. This is not possible in HyperGraphQL since we have to define for every resource a type. Moreover, every type and field in the schema can only be associated with one service (Chapter 3 Section~\ref{subsec:configuration}). 

On the other hand, GraphQL-LD operates schema-less. It translates a GraphQL query into a SPARQL query aided by a JSON-LD context. This context is responsible for mapping the GraphQL definitions to unique IRIs. The benefit of using no schema is that GraphQL is more flexible in the sense that RDF sources can be queried in the same fashion as one would use SPARQL queries against the endpoint. This removes the restrictions on the data that can be queried, and allows to simple query and relationships between nodes without mentioning the type of the nodes.

Since HyperGraphQL uses a schema, another advantage is that it distinguishes what should be queried as a type and what should be treated as a property~\cite{Werbrouck2019a}. On the other hand, since GraphQL is predicate based, there is no direct way to distinguish this. We have to use workarounds to query for specific class.


\section{Intermediary server}
We create and run a HyperGraphQL instance by setting up an intermediary server using a configuration file and an annotated schema. A GraphQL endpoint is exposed that points to the service or Linked Data source configured in the parameters of the configuration file. However, when one needs to change the service, it required to stop the running intermediary server and create a new configuration file. Additionally, the annotated schema also required to be changed to comply with the new service. 

On the other hand, GraphQL-LD does not require the setup of a server. It can be executed simply via the command line by providing a GraphQL query, JSON-LD context and SPARQL endpoint. This implementation is relatively easier and provides more flexibility when one needs to query a different Linked Data source. 


\section{Updating data}
Updating existing data is an important feature when working with knowledge graphs. GraphQL implements this using the mutation operation type. Mutations allow the creation, update and deletion of data. SPARQL implements creation and deletion using the operations \texttt{INSERT} and \texttt{DELETE} respectively, and update using a combination of the two operations. However, neither GraphQL-LD nor HyperGraphQL currently support mutations.  


\section{Filter Labels and Descriptions}
When querying Wikidata we can use the specialized service with \texttt{wikibase:label}\footnote{short for \texttt{<http://wikiba.se/ontology\#label>}} in SPARQL queries to fetch labels and descriptions in specific languages. Alternatively, we can also use the \texttt{rdf:label} and \texttt{schema:description}\footnote{short for \texttt{<http://schema.org/description>}} properties along with a \texttt{FILTER} function as is common when querying RDF graphs. 

We cannot use the specialized service in any of the two approaches. Instead the \texttt{rdf:label} and \texttt{schema:description} properties are used. GraphQL-LD does not support the use of filter, and hence we cannot fetch labels in a particular language. On the other hand, in HyperGraphQL we can specify the language of the fetched string (Chapter 3 Secion\ref{subsec:annotated-schema}). The examples shown in this chapter demonstrate this.

\section{Reverse Querying}
\label{sec:reverse}
GraphQL-LD supports reversing the direction of a property by the use of \texttt{@reverse} context option in the JSON-LD context. Standard GraphQL specifications do not have this feature. Reverse fields are useful in cases where we want to reverse the relationship between a parent and a child node. This is similar to the inverse path feature of property paths that reverses the direction of edge traversal.\footnote{https://www.w3.org/TR/sparql11-query/\#propertypaths} HyperGraphQL does not have this feature.

Listing~\ref{lst:37} shows a SPARQL query that fetches the siblings of Johann Sebastian Bach using the inverse path feature.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:37, caption={SPARQL query showing usage of inverse path}, language=SPARQL]
SELECT ?sibling ?siblingLabel
WHERE
{
  wd:Q1339 wdt:P22 ?father.
  ?father ^wdt:P22 ?sibling.
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}

We can generate a similar query in GraphQL-LD. The JSON-LD context that we had defined in Listing XYZ has \textit{hasFather} and \textit{ofFather} entries, both of which point to the IRI pointing to father property in Wikidata. However, the \textit{ofFather} entry has the \texttt{@reverse} keyword added in the JSON-LD context that reverse the direction of the property. We use \texttt{(\_:JohannSebastianBach)} as an argument in id to define the id to be \textit{JohannSebastianBach}. This is how we can set a \textit{block scoped id} in GraphQL-LD.\footnote{https://github.com/rubensworks/graphql-to-sparql.js\#setting-a-block-scoped-id}

Listing~\ref{lst:38} shows the GraphQL query and generated SPARQL query in GraphQL-LD.

\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:38, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(_: JohannSebastianBach)
  hasFather {
  	fatherOf {
  	  id
      label
    }
  }
}


SELECT ?hasFather_fatherOf_id ?hasFather_fatherOf_label WHERE {
  <http://www.wikidata.org/entity/Q1339> <http://www.wikidata.org/prop/direct/P22> ?hasFather.
  ?hasFather_fatherOf_id <http://www.wikidata.org/prop/direct/P22> ?hasFather;
    <http://www.w3.org/2000/01/rdf-schema#label> ?hasFather_fatherOf_label.
}
\end{lstlisting}
\end{minipage}


\section{Optional Fields}

In GraphQL-LD, GraphQL query fields are non-null by default. They can be defined nullable using the \texttt{@optional} directive. This belongs to one of the custom directives provided by GraphQL-LD and is not implemented in the standard specifications of GraphQL. In SPARQL we use the corresponding \texttt{OPTIONAL} feature in triple patterns.

HyperGraphQL always translates GraphQL fields into \texttt{OPTIONAL} SPARQL triple patterns. GraphQL allows to define fields to be non-null in the schema. However, HyperGraphQL does not support this feature and we cannot implement it in its annotated schema. As a result of this limitation, we get more results than expected in HyperGraphQL when writing GraphQL queries. 

Listing~\ref{lst:39} shows a SPARQL query that fetches the colours of chemical compounds and if possible the RGB of the colours.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:39, caption={SPARQL query showing usage of OPTIONAL feature}, language=SPARQL]
SELECT ?compound ?color ?rgb  WHERE
{
  ?compound wdt:P31 wd:Q11173;
            wdt:P462 ?color.
  OPTIONAL { ?color wdt:P465 ?rgb. }
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}

Listings~\ref{lst:40} and \ref{lst:41} show the GraphQL query and generated SPARQL query in GraphQL-LD and HyperGraphQL respectively.

\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:40, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(instance:compound) {
    id
    label
    color {
      id
      label
      rgb @optional
    }
  }
}


SELECT ?id ?id_id ?id_label ?id_color_id ?id_color_label ?id_color_rgb WHERE {
  ?id_id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q11173>;
  %\phantom{?id\_id }%<http://www.w3.org/2000/01/rdf-schema#label> ?id_label;
  %\phantom{?id\_id }%<http://www.wikidata.org/prop/direct/P462> ?id_color_id.
  ?id_color_id <http://www.w3.org/2000/01/rdf-schema#label> ?id_color_label.
  OPTIONAL { ?id_color_id <http://www.wikidata.org/prop/direct/P465> ?id_color_rgb. }      
}
\end{lstlisting}
\end{minipage}



\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:41, caption={GraphQL query and generated SPARQL query in HyperGraphQL}, language=SPARQL]
{
  ChemicalCompound_GET {
    _id
    label(lang: "en")
    color {
      _id
      label(lang: "en")
      rgb
    }
  }
}


SELECT * WHERE { 
  { 
    SELECT ?x_1 WHERE { 
      ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q11173> . 
    }  
  }  
  OPTIONAL { 
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1 .
    FILTER (lang(?x_1_1) = "en") .  
  }  
  OPTIONAL { 
    ?x_1 <http://www.wikidata.org/prop/direct/P462> ?x_1_2 .
    ?x_1_2 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1075> . 
    OPTIONAL { 
      ?x_1_2 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_2_1 .
      FILTER (lang(?x_1_2_1) = "en") .  
    }  
    OPTIONAL { 
      ?x_1_2 <http://www.wikidata.org/prop/direct/P465> ?x_1_2_2 . 
    }  
  }  
}
\end{lstlisting}
\end{minipage}


\section{LIMIT and OFFSET}

In GraphQL-LD we can define the maximum number of results for a field with the \texttt{first} argument. Additionally, we can specify the index of the first result using the \texttt{offset} argument. Limits and offsets are part of pagination technique in GraphQL. These are similar to \texttt{LIMIT} and \texttt{OFFSET} in SPARQL.

In HyperGraphQL we can pass \texttt{limit} and \texttt{offset} arguments to every \textit{TypeName\_GET} query field.

Listing~\ref{lst:42} shows a SPARQL query to fetch items whose value of \texttt{instance of} is a house cat. The \texttt{LIMIT} is set to \texttt{10} and \texttt{OFFSET} to \texttt{2}.


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:42, caption={SPARQL query showing usage of LIMIT and OFFSET}, language=SPARQL]
SELECT ?item ?itemLabel
WHERE
{
    ?item wdt:P31 wd:Q146;.
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
} OFFSET 2 LIMIT 10
\end{lstlisting}
\end{minipage}

Listings~\ref{lst:43} and \ref{lst:44} show the GraphQL query and generated SPARQL query in GraphQL-LD and HyperGraphQL respectively.


\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:43, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(instance:cat first: 10 offset: 2) {
    id
    label
  }
}


SELECT ?id ?id_id ?id_label WHERE {
  SELECT ?id_id ?id_label WHERE {
    ?id_id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q146>;
    %\phantom{?id\_id }%<http://www.w3.org/2000/01/rdf-schema#label> ?id_label.
  }
  OFFSET 2
  LIMIT 10
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:44, caption={GraphQL query and generated SPARQL query in HyperGraphQL}, language=SPARQL]
{
  Cat_GET(limit: 10, offset: 2) {
    _id
    label(lang: "en")
  }
}


SELECT * WHERE {
  {
    SELECT ?x_1 WHERE {
      ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q146> .
    } LIMIT 10 OFFSET 2
  }
  OPTIONAL {
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1 .
    FILTER (lang(?x_1_1) = "en") .
  }
}
\end{lstlisting}
\end{minipage}


\section{COUNT Aggregate Function}

In GraphQL-LD we can use the \texttt{totalCount} field to find the total number of items that match a certain query. This is another pagination technique used in GraphQL and is useful to get the total numbers of results available irrespective of any limit or offset fields. This is similar to the \texttt{COUNT} aggregate function in SPARQL that counts the number of triples or other query elements that match a particular pattern. 

HyperGraphQL does not support the totalCount feature.

Listing~\ref{lst:45} shows a SPARQL query that returns the count of the total number of humans listed in Wikidata.


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:45, caption={SPARQL query showing usage of COUNT}, language=SPARQL]
SELECT (COUNT(*) AS ?count)
WHERE {
  ?item wdt:P31 wd:Q5 .
}
\end{lstlisting}
\end{minipage}

Listing\ref{lst:46} shows the GraphQL query and generated SPARQL query in GraphQL-LD. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:46, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(instance: human){
    totalCount
  }
}


SELECT ?id ?id_totalCount WHERE { 
  SELECT (COUNT(?id) AS ?id_totalCount) WHERE { 
    ?id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q5>. 
  } 
}
\end{lstlisting}
\end{minipage}


\section{VALUES}

SPARQL uses the \texttt{VALUES} keyword to specify a set of values for one or more variables that are used as inputs to queries. GraphQL-LD does not support this feature. 

HyperGraphQL exposes the query field \textit{TYPENAME\_GET\_BY\_ID} for every type in the annotated schema. This field takes a list of instances of that particular type and uses the \texttt{VALUES} keyword in the generated SPARQL query to inject the list as input into the subject node of the triple pattern - \texttt{?subject rdf:type \textit{<IRI of type>}}, where IRI of type is the IRI that points to the \textit{TYPENAME}. At the moment only injection of values in subject nodes of such triple patterns is supported.

Listing~\ref{lst:47} shows a SPARQL query that fetches the destinations that can be reached from Antwerp International Airport. Antwerp International Airport is passed into the \textit{?airport} variables using the \texttt{VALUE} keyword.


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:47, caption={SPARQL query showing usage of VALUES}, language=SPARQL]
SELECT ?connectsairport ?connectsairportLabel ?place_served ?place_servedLabel ?coor
WHERE
{
  VALUES ?airport { wd:Q17480 }  
  ?airport wdt:P81 ?connectsairport ;
           wdt:P625 ?base_airport_coor .
  ?connectsairport wdt:P931 ?place_served ;
                   wdt:P625 ?coor .
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:48} shows the GraphQL query and generated SPARQL query in HyperGraphQL. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:48, caption={GraphQL query and generated SPARQL query in HyperGraphQL}, language=SPARQL]
{
  Airport_GET_BY_ID(uris: ["http://www.wikidata.org/entity/Q17480"]) {
    _id
    label(lang: "en")
    connectingLine {
      _id
      label(lang: "en")
      placeServed {
        _id
        	label(lang: "en")
        	coordinateLocation
      }
    }
  }
} 


SELECT * WHERE {
  VALUES ?x_1 { <http://www.wikidata.org/entity/Q17480> }
  ?x_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1248784> .
  OPTIONAL {
    ?x_1 <http://www.wikidata.org/prop/direct/P81> ?x_1_1 .
    ?x_1_1 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q1248784> .
    OPTIONAL {
      ?x_1_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1_1 .
      FILTER (lang(?x_1_1_1) = "en") .
    }
    OPTIONAL {
      ?x_1_1 <http://www.wikidata.org/prop/direct/P931> ?x_1_1_2 .
      ?x_1_1_2 <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q515> .
      OPTIONAL {
        ?x_1_1_2 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_1_2_1 .
        FILTER (lang(?x_1_1_2_1) = "en") .
      }
      OPTIONAL {
        ?x_1_1_2 <http://www.wikidata.org/prop/direct/P625> ?x_1_1_2_2 .
      }
    }
  }
  OPTIONAL {
    ?x_1 <http://www.w3.org/2000/01/rdf-schema#label> ?x_1_2 .
    FILTER (lang(?x_1_2) = "en") .
  }
}
\end{lstlisting}
\end{minipage}

\section{Arguments}

In GraphQL we can pass arguments to pass data to every field or object, where object is a type in the GraphQL schema. This is in addition to the predefined arguments such as \texttt{first} and \texttt{offset}. GraphQL-LD also allows passing arguments into fields or objects. These are converted into subject or object nodes of triples in SPARQL.

HyperGraphQL does not allow users to pass arguments into fields or objects other than the predefined ones. (See Chapter 3 Section~\ref{subsec:annotated-schema})

Listing~\ref{lst:49} shows a SPARQL query used to fetch the cathedrals in Paris. 


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:49, caption={SPARQL query to fetch cathedrals in Paris}, language=SPARQL]
SELECT ?item ?itemLabel ?placeLabel
WHERE
{
  ?item wdt:P31 wd:Q2977 .
  ?item wdt:P131 ?place .
  ?place wdt:P131 wd:Q90 .
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en" . }
}
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:50} shows the GraphQL query and generated SPARQL query in GraphQL-LD. The argument (place: Paris) is passed as a parameter to the id field of the place object.

\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:50, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(instance: cathedral){
    id
    label
    place{
      id (place: Paris)
      label
    }
  }
}


SELECT ?id ?id_id ?id_label ?id_place_id ?id_place_label WHERE {
  ?id_id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/Q2977>;
         <http://www.w3.org/2000/01/rdf-schema#label> ?id_label;
         <http://www.wikidata.org/prop/direct/P131> ?id_place_id.
  ?id_place_id <http://www.wikidata.org/prop/direct/P131> <http://www.wikidata.org/entity/Q90>;
               <http://www.w3.org/2000/01/rdf-schema#label> ?id_place_label.
}
\end{lstlisting}
\end{minipage}


\section{Alternative Fields}

In GraphQL-LD we can use multiple fields for retrieving a value via the \texttt{alt} argument in fields. Multiple alternatives can be defines by inserting them in a list: \texttt{\textit{field}(alt: [alt1, alt2, alt3, â€¦])}. This is similar to matching alternative paths in property paths using the vertical bar symbol to always match a path of length one. We use this when we want the path to use any one of the properties in the alternative paths. 

HyperGraphQL does not support defining alternative fields.

Listing~\ref{lst:51} shows a query to fetch father or mother of Johann Sebastian Bach.


\begin{minipage}{\linewidth}
\begin{lstlisting}[columns=fullflexible, label=lst:51, caption={SPARQL query showing the usage of alternative paths}, language=SPARQL]
SELECT ?parent ?parentLabel
WHERE
{
  wd:Q1339 (wdt:P22|wdt:P25) ?parent.
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:52} shows the GraphQL query and generated SPARQL query in GraphQL-LD. We used the parent alias to represent a father or mother.

\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:52, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(_: JohannSebastian)
  parent: hasFather(alt: hasMother){
    id
    label
  }
}


SELECT ?parent_id ?parent_label WHERE {
  ?parent_id <http://www.w3.org/2000/01/rdf-schema#label> ?parent_label.
  <http://www.wikidata.org/entity/Q1339> (<http://www.wikidata.org/prop/direct/P22>|
  <http://www.wikidata.org/prop/direct/P25>) ?parent_id.
}
\end{lstlisting}
\end{minipage}


\section{Default vocabulary}

We can set a default vocabulary (namespace) for all values of keys in a JSON-LD context file with the \texttt{@vocab} keyword. In the JSON-LD context file in Listing~\ref{lst:35} we set the default vocabulary to \texttt{http://www.wikidata.org/entity/} by \texttt{@vocab": "http://www.wikidata.org/entity/}.

GraphQL-LD can make use of the default vocabulary as it uses a JSON-LD context. Since HypergraphQL does not use JSON-LD context, this cannot be used in its implementation. 

Listing~\ref{lst:53} shows a GraphQL query in GraphQL-LD and the corresponding generated SPARQL query that fetches the names of items that are instances of humans in Wikidata. We do not have a key for the argument human. As a result, human will have the IRI \texttt{http://www.wikidata.org/entity/human}. 


\begin{minipage}{\linewidth}
\begin{lstlisting}[label=lst:53, caption={GraphQL query and generated SPARQL query in GraphQL-LD}, language=SPARQL]
query {
  id(instance: human){
    name
  }
}

SELECT ?id ?id_name WHERE {
  ?id <http://www.wikidata.org/prop/direct/P31> <http://www.wikidata.org/entity/human>;
      <http://www.wikidata.org/prop/direct/P735> ?id_name.
}
\end{lstlisting}
\end{minipage}


From the example we see that human is appended at the end of the default vocabulary. The same IRI is generated for human when it has an entry in the JSON-LD context but does not have a value. Moreover, if human has a non-IRI value then that value is appended at the end of the default vocabulary. 

When querying Wikidata, we use \texttt{http://www.wikidata.org/entity/} to represent entity nodes and \texttt{http://www.wikidata.org/prop/direct/} for predicates of truthy statements. We can only set one namespace as the default vocabulary. Since items are significantly larger in number than properties, setting the vocabulary to \texttt{http://www.wikidata.org/entity/} is a good option as it might not be possible to define all items in a JSON-LD context.



Table~\ref{tab:2} provides a comparison of the two approaches with the GraphQL features (See Chapter 2, Section~\ref{sec:graphql}).


\begin{table}[h]
	\begin{center}
		\caption{Comparison of the two approaches with GraphQL features}
		\label{tab:2}
		\renewcommand{\arraystretch}{2}
		\begin{tabular}{ccc}
		

			\toprule
			
			& \textbf{GraphQL-LD} & \textbf{HyperGraphQL}  \\ 
		
			\midrule
			
			Arguments & \cmark & \cmark \tablefootnote{only defined ones}	 \\
			
			Aliases & \cmark & \cmark  \\ 
			
			Fragments & \cmark & \cmark \tablefootnote{\cite{Werbrouck2019a} mentions possible but we could not implement it}  \\ 
			
			Inline Fragments & \cmark & \cmark \tablefootnote{Same issue as with Fragments}  \\ 
			
			
			
			Variables & \cmark & \cmark  \\ 
			
			Directives & \cmark & \cmark \\ 
			
			Mutations & \xmark & \xmark \\ 
			
			Pagination & \cmark & \cmark \\ 
			
			Introspection & \xmark & \cmark \\ 
			
			Nullability & \cmark & \cmark \tablefootnote{by default} \\ 
				
			\bottomrule

		\end{tabular}
	\end{center}
\end{table}


Table~\ref{tab:3} provides a comparison of the two approaches with some standard SPARQL features.


\begin{table}[h]
	\begin{center}
		\caption{Comparison of the two approaches with some standard SPARQL features}
		\label{tab:3}
		\renewcommand{\arraystretch}{2}
		\begin{tabular}{ccc}
		

			\toprule
			
			& \textbf{GraphQL-LD} & \textbf{HyperGraphQL}  \\ 
		
			\midrule
			
			LIMIT & \cmark & \cmark	 \\
			
			OFFSET & \cmark & \cmark  \\ 
			
			ORDER BY & \xmark & \xmark  \\ 
			
			GROUP BY & \xmark & \xmark  \\ 
			
			FILTER & \xmark & \cmark \tablefootnote{only for lang labels}  \\ 
			
			ASK/CONSTRUCT/DESCRIBE & \xmark & \xmark \\ 
			
			DISTINCT & \xmark & \xmark \\ 
			
			UNION & \xmark & \xmark \\ 
			
			MINUS & \xmark & \xmark \\ 
			
			OPTIONAL & \cmark & \cmark \\ 
			
			VALUES & \xmark & \cmark \tablefootnote{only for subject queries} \\ 
			
			BIND & \xmark & \xmark \\ 	
			
			COUNT & \cmark & \xmark \\ 			
			
			Other Aggregates & \xmark & \xmark \\ 	
			
			HAVING & \xmark & \xmark \\ 	
			
			Reverse Paths & \cmark & \xmark \\ 
			
			Alternative paths & \cmark & \xmark \\ 
			
			
			\bottomrule

		\end{tabular}
	\end{center}
\end{table}


Both GraphQL-LD and HyperGraphQL are potential solutions to querying RDF graphs using GraphQL. They have their own benefits and limitations. Since GraphQL queries tree structures, it is less expressive than SPARQL~\cite{Werbrouck2019}. On the other hand, GraphQL facilitates querying basic RDF data. The two approaches support many standard features that are typical in GraphQL. However, both of the approaches are work in progress and have their own limitations. Hence, not all the expressivity of GraphQL can currently be implemented~\cite{Werbrouck2019}.

When comparing between each other, GraphQL-LD is a more lightweight implementation of GraphQL for querying linked data. It is more suitable when we want to query different datasets by changing our endpoints as it operates without a schema and does not require the setup of a server. It also takes less time to implement it as opposed to HyperGraphQL.

On the other hand, HyperGraphQL is a more powerful implementation. It is preferable when we want to query large, complex datasets such as knowledge graphs like Wikidata. An uniform setup with predefined set of types and fields in the annotated schema makes it stable and friendlier to use~\cite{Werbrouck2019a}. 

